#!/usr/bin/python
# -*- coding: utf-8 -*-
# 第47题 自动化测试 
'''
为了确认游戏的功能是否正常，你需要一遍一遍地在你的游戏中输入命令。这个过程是很枯燥无味的。如果能写一小段代码用来测试你的代码岂不是更好?然后只要你对程序做了任何修改，或者添加了什么新东西，你只要“跑一下你的测试”，而这些测试能确认程序依然能正确运行。这些自动测试不会抓到所有的 bug， 但可以让你无需重复输入命令运行你的代码，从而为你节约很多时间。

从这一章开始，以后的练习将不会有“你应该看到的结果”这一节，取而代之的是一个“你应该测试的东西”一节。从现在开始，你需要为自己写的所有代码写自动化测试，而这将让你成为一个更好的程序员。

我不会试图解释为什么你需要写自动化测试。我要告诉你的是，你想要成为一个程序员，而程序的作用是让无聊冗繁的工作自动化，测试软件毫无疑问是无聊冗繁的，所以你还是写点代码让它为你测试的更好。

这应该是你需要的所有的解释了。因为你写单元测试的原因是让你的大脑更加强健。你读了这本书，写了很多代码让它们实现一些事情。现在你将更进一步，写出懂得你写的其他代码的代码。这个写代码测试你写的其他代码的过程将强迫你清楚的理解你之前写的代码。这会让你更清晰地了解你写的代码实现的功能及其 原理，而且让你对细节的注意更上一个台阶。

'''
## 撰写测试用例
'''
我们将拿一段非常简单的代码为例，写一个简单的测试，这个测试将建立在上节 我们创建的项目骨架上面。
首先从你的项目骨架创建一个叫做ex47的项目。确认该改名称的地方都有改过， 尤其是test/ex47_tests.py这处不要写错，另外运行 nosetest 确认一下没有错误信息。检查一下tests/skel_tests.pyc这个文件，有的话就把它删掉， 这一点需要尤其注意。
接下来创建一个简单的 ex47/game.py文件，里边放一些用来被测试的代码。我们现在放一个傻乎乎的小 class 进去，用来作为我们的测试对象:
'''
#代码开始

class Room(object):
	
	def _init_(self,name,description):
		self.name = name
		self.description = description
		self.paths = {}
		
	def go(self,direction):
		return self.paths.get(direction,None)
		
	def ass_paths(self,paths):
		self.paths.update(paths)
		
# 准备好这个文件，接下来把测试骨架改为这个样子：

from nose.tools import *
from ex47.game import Room

def test_room():
	gold = Room("GoldRoom",
	"""This room has gold in it you can grab.There's a
	door to te north.""")
	assert_equal(gold.name,"GoldRoom")
	assert_equal(gold.paths,{})
	
def test_room_paths():
	center = Room("Center","Test room in the center.")
	north = Room("North","Test room in the north.")
	south = Room("South","Test room in the south.")
	
	center.add_paths({'north':north,'south':south})
	assert_equal(center.go('north'),north)
	assert_equal(center.go('south'),south)
	
def test_map():
	start = Room("Start","You can go west and down a hole.")
	west =Room("Trees","There are trees here,you can go east")
	down =Room("Dungeon","It's dark down here,you can go up.")
	
	start.add_paths({'west'.west,'down':down})
	west.add_paths({'east':start})
	down.add_paths({'up':start})
	
	assert_equal(start.go('west'),west)
	assert_equal(start.go('west').go('east'),start)
	assert_equal(start.go('down').go('up'),start)

## 文字：
''''
这个文件 import了你在ex47.game创建的Room这个类，接下来我们要做的就 是测试它。于是我们看到一系列的以 test_ 开头的测试函数，它们就是所谓的“测 试用例(test case)”，每一个测试用例里面都有一小段代码，它们会创建一个或者一些房间，然后去确认房间的功能和你期望的是否一样。它测试了基本的房间功能，然后测试了路径，最后测试了整个地图。
这里最重要的函数时assert_equal，它保证了你设置的变量，以及你在Room里设置的路径和你的期望相符。如果你得到错误的结果的话，nosetests将会打印出一个错误信息，这样你就可以找到出错的地方并且修正过来。
'''
#测试指南
'''
在写测试代码时，你可以照着下面这些不是很严格的指南来做:
1. 测试脚本要放到tests/目录下，并且命名为BLAH_tests.py，否
则 nosetests 就不会执行你的测试脚本了。这样做还有一个好处就是防止测试代 码和别的代码互相混掉。
2. 为你的每一个模组写一个测试。
3. 测试用例(函数)保持简短，但如果看上去不怎么整洁也没关系，测试用例一般都
有点乱。
4. 就算测试用例有些乱，也要试着让他们保持整洁，把里边重复的代码删掉。创建一
些辅助函数来避免重复的代码。当你下次在改完代码需要改测试的时候，你会感谢
  我这一条建议的。重复的代码会让修改测试变得很难操作。
5. 最后一条是别太把测试当做一回事。有时候，更好的方法是把代码和测试全部删掉，
然后重新设计代码。

# 你应该看到的结果

~/projects/simplegame $ nosetests ...-------------------------------------------------------- --------------Ran 3 tests in 0.007sOK177
 如果一切工作正常的话，你看到的结果应该就是这

加分习题
1. 仔细读读 nosetest 相关的文档，再去了解一下其他的替代方案。
2. 了解一下 Python 的 “doc tests” ，看看你是不是更喜欢这种测试方式。
3. 改进你游戏里的 Room，然后用它重建你的游戏，这次重写，你需要一边写代码，
一边把单元测试写出来。


'''

	
	
	




# 运行后的结果：
'''
习题 45: 对象、类、以及从属关系 

有一个重要的概念你需要弄明白，那就是“类(class)”和“对象(object)”的区别。问
题在于，class 和object并没有真正的不同。它们其实是同样的东西，只是在不同的时间名字不同罢了。我用禅语来解释一下吧:
鱼和泥鳅有什么区别?
这个问题有没有让你有点晕呢?说真的，坐下来想一分钟。我的意思是说，鱼和泥鳅是不一样，不过它们其实也是一样的是不是?泥鳅是鱼的一种，所以说没什 么不同，不过泥鳅又有些特别，它和别的种类的鱼的确不一样，比如泥鳅和黄鳝 就不一样。所以泥鳅和鱼既相同又不同。怪了。这个问题让人晕的原因是大部分人不会这样去思考问题，其实每个人都懂这一点， 你无须去思考鱼和泥鳅的区别，因为你知道它们之间的关系。你知道泥鳅是鱼的一种，而且鱼还有别的种类，根本就没必要去思考这类问题。
让我们更进一步，假设你有一只水桶，里边有三条泥鳅。假设你的好人卡多到没地方用，于是你给它们分别取名叫小方，小斌，小星。现在想想这个问题:
小方和泥鳅有什么区别? 这个问题一样的奇怪，但比起鱼和泥鳅的问题来还好点。你知道小方是一条泥鳅，所以他并没什么不同，他只是泥鳅的一个“实例(instance)”。小斌和小星一样也是泥鳅的实例。我的意思是说，它们是由泥鳅创建出来的，而且代表着和泥鳅一样 的属性。所以我们的思维方式是(你可能会有点不习惯):鱼是一个“类(class)”，泥鳅是一个“类(class)”，而小方是一个“对象(object)”。仔细想想，然后我再一点一点慢 慢解释给你。鱼是一个“类”，表示它不是一个真正的东西，而是一个用来 述具有同类属性的 实例的概括性词汇。
你有鳍?你有鳔?你住在水里?好吧那你就是一条鱼。后来河蟹养殖专家路过，看到你的水桶，于是告诉你:“小伙子，你这些鱼是泥 鳅。” 专家一出，真相即现。并且专家还定义了一个新的叫做“泥鳅”的“类”，而这个“类”又有它特定的属性。细长条?有胡须?爱钻泥巴?吃起来味道还可以? 那你就是一条泥鳅。
最后家庭煮父过来了，他跟河蟹专家说:“非也非也，你看到的是泥鳅，我看到的是小方，而且我要把小方和剁椒配一起做一道小菜。”于是你就有了一只叫做 小方的泥鳅的“实例(instance)”(泥鳅也是鱼的一个“实例”)，并且你使用了它(把 它塞到你的胃里了)，这样它就是一个“对象(object)”。
这会你应该了解了:小方是泥鳅的成员，而泥鳅又是鱼的成员。这里的关系式:
对象属于某个类，而某个类又属于另一个类。

写成代码是什么样子？

这个概念有点绕人，不过实话说，你只要在创建和使用 class 的时候操心一下 就可以了。我来给你两个区分 Class 和 Object 的小技巧。
首先针对类和对象，你需要学会两个说法，“is-a(是啥)”和“has-a(有啥)”。“是啥”要用在谈论“两者以类的关系互相关联”的时候，而“有啥”要用在“两者无共同点， 仅是互为参照”的时候。
接下来，通读这段代码，将每一个注解为 ##?? 的位置标明他是“is-a”还是“has-a”的关系，并讲明白这个关系是什么。在代码的开始我还举了几个例子，所以你只 要写剩下的就可以了。
记住，“是啥”指的是鱼和泥鳅的关系，而“有啥”指的是泥鳅和鳃的关系。(译注:为了解释方便，译文使用了中文鱼名。原文使用的是“三文鱼(salmon)”和“大比目鱼(halibut)”，名字也是英文常用人名。)


关于 class Name(object)
记得我曾经强迫让你使用 class Name(object) 却没告诉你为什么吧，现在你 已经知道了“类”和“对象”的区别，我就可以告诉你原因了。如果我早告诉你的话， 你可能会晕掉，也学不会这门技术了。
真正的原因是在 Python 早期，它对于class的定义在很多方面都是严重有问 题的。当他们承认这一点的时候已经太迟了，所以逼不得已，他们需要支持这种有问题的 class。为了解决已有的问题，他们需要引入一种“新类”，这样的话“旧 类”还能继续使用，而你也有一个新的正确的类可以使用了。
这就用到了“类即是对象”的概念。他们决定用小写的“object”这个词作为一个类， 让你在创建新类时从它继承下来。有点晕了吧?一个类从另一个类继承，而后者 虽然是个类，但名字却叫“object”......不过在定义类的时候，别忘记要从 object 继承就好了。
的确如此。一个词的不同就让这个概念变得更难理解，让我不得不现在才讲给你。
现在你可以试着去理解“一个是对象的类”这个概念了，如果你感兴趣的话。
不过我还是建议你别去理解了，干脆完全忘记旧格式和新格式类的区别吧，就假 设 Python 的 class 永远都要求你加上 (object) 好了，你的脑力要留着思考更 重要的问题。


加分习题
1. 研究一下为什么 Python 添加了这个奇怪的叫做object的 class，它究竟有什么 含义呢?
2. 有没有办法把Class当作Object使用呢?
3. 在习题中为 animals、fish、还有 people 添加一些函数，让它们做一些事情。看看
当函数在 Animal 这样的“基类(base class)”里和在 Dog 里有什么区别。
4. 找些别人的代码，理清里边的“是啥”和“有啥”的关系。
5. 使用列表和字典创建一些新的一对应多的“has-many”的关系。
6. 你认为会有一种“has-many”的关系吗?阅读一下关于“多重继承(multiple
inheritance)”的资料，然后尽量避免这种用法。
'''


